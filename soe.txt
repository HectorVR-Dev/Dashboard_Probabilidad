
"""
    def show_filters(self):
        # se encarga de mostrar filtros interactivos para personalizar el análisis de datos en la sección correspondiente de la aplicación.
        # Utiliza los elementos seleccionados por el usuario para filtrar el DataFrame principal y luego muestra los resultados en una tabla.
        # Se implementan varios tipos de filtros como selección múltiple, deslizadores para rangos numéricos y casillas de verificación.
        # La función también realiza ciertas transformaciones en los datos, como renombrar columnas y ajustar la visualización de ciertas
        # variables. Finalmente, muestra el DataFrame filtrado en una tabla con algunas columnas especiales configuradas para una mejor
        # visualización.
        self.modr = self.df
        st.title("Filtros Interactivos")
        st.write(
            "Utiliza los filtros interactivos para personalizar tu análisis de datos.")

        BT = st.multiselect(label="**Filtros**",
                            options=self.vars)

        with st.expander(label="**Filtros aplicados**", expanded=False):
            if "COD_PLAN" in BT:
                self.PLAN = pd.read_csv("data/COD_PLAN.csv")
                self.CreateMultiSelect(label="COD_PLAN",
                                       column="COD_PLAN",
                                       options=self.PLAN.iloc[:, 1].tolist(
                                       ),
                                       fuction=self._CreateMultiSelect_WithDDF,
                                       df=self.PLAN)

            if "AVANCE_CARRERA" in BT:
                self.CreateSlider(column="AVANCE_CARRERA",
                                  min_value=0.,
                                  max_value=100.,
                                  values=(0., 100.),
                                  format="%.1f")

            if "COD_ACCESO" in BT:
                self.ACCESO = pd.read_csv("data/COD_ACCESO.csv")
                self.CreateMultiSelect(label="COD_ACCESO",
                                       column="COD_ACCESO",
                                       options=self.ACCESO.iloc[:, 1].tolist(
                                       ),
                                       fuction=self._CreateMultiSelect_WithDDF,
                                       df=self.ACCESO)


            if "COD_SUBACCESO" in BT:
                self.SUBACCESO = pd.read_csv("data/COD_SUBACCESO.csv")
                self.CreateMultiSelect(label="COD_SUBACCESO",
                                       column="COD_SUBACCESO",
                                       options=self.SUBACCESO.iloc[:, 1].tolist(
                                       ),
                                       fuction=self._CreateMultiSelect_WithDDF,
                                       df=self.SUBACCESO)



            if "GENERO" in BT:
                self.CreateMultiSelect(label="GENERO",
                                       column="GENERO",
                                       options=self.modr["GENERO"].drop_duplicates(
                                       ),
                                       fuction=self._CreateMultiSelect_WithoutDDF)

            if "EDAD" in BT:
                min = self.df["EDAD"].min()
                max = self.df["EDAD"].max()
                self.CreateSlider(column="EDAD",
                                  min_value=min,
                                  max_value=max,
                                  values=(min, max),
                                  format="%d")

            if "PAPA" in BT:
                min = self.df["PAPA"].min()
                max = self.df["PAPA"].max()
                self.CreateSlider(column="PAPA",
                                  min_value=min,
                                  max_value=max,
                                  values=(min, max),
                                  format="%.1f")

            if "PROME_ACADE" in BT:
                min = self.df["PROME_ACADE"].min()
                max = self.df["PROME_ACADE"].max()
                self.CreateSlider(column="PROME_ACADE",
                                  min_value=min,
                                  max_value=max,
                                  values=(min, max),
                                  format="%0.1f")

            if "PBM_CALCULADO" in BT:
                min = self.df["PBM_CALCULADO"].min()
                max = self.df["PBM_CALCULADO"].max()
                self.CreateSlider(column="PBM_CALCULADO",
                                  min_value=min,
                                  max_value=max,
                                  values=(min, max),
                                  format="%d")

            if "CONVOCATORIA" in BT:
                self.CreateMultiSelect(label="CONVOCATORIA",
                                       column="CONVOCATORIA",
                                       options=self.df["CONVOCATORIA"].drop_duplicates(
                                       ),
                                       fuction=self._CreateMultiSelect_WithoutDDF)

            if "APERTURA" in BT:
                self.CreateMultiSelect(label="APERTURA",
                                       column="APERTURA",
                                       options=self.df["APERTURA"].drop_duplicates(
                                       ),
                                       fuction=self._CreateMultiSelect_WithoutDDF)

            if "T_DOCUMENTO" in BT:
                self.CreateMultiSelect(label="T_DOCUMENTO",
                                       column="T_DOCUMENTO",
                                       options=self.df["T_DOCUMENTO"].drop_duplicates(
                                       ),
                                       fuction=self._CreateMultiSelect_WithoutDDF)

            if "NUMERO_MATRICULAS" in BT:
                min = int(self.df["NUMERO_MATRICULAS"].min())
                max = int(self.df["NUMERO_MATRICULAS"].max())
                self.CreateSlider(column="NUMERO_MATRICULAS",
                                  min_value=min,
                                  max_value=max,
                                  values=(min, max),
                                  format="%d",
                                  step=1)

            if "ESTRATO" in BT:
                min = int(self.df["ESTRATO"].min())
                max = int(self.df["ESTRATO"].max())
                self.CreateSlider(column="ESTRATO",
                                  min_value=min,
                                  max_value=max,
                                  values=(min, max),
                                  format="%d",
                                  step=1)

            if "VICTIMAS_DEL_CONFLICTO" in BT:
                self.CreateMultiSelect(label="VICTIMAS_DEL_CONFLICTO",
                                       column="VICTIMAS_DEL_CONFLICTO",
                                       options=["SI", "NO"],
                                       fuction=self._CreateMultiSelectModified,
                                       binary=True)

            if "DISCAPACIDAD" in BT:
                self.CreateMultiSelect(label="DISCAPACIDAD",
                                       column="DISCAPACIDAD",
                                       options=self.df["DISCAPACIDAD"].drop_duplicates(
                                       ),
                                       fuction=self._CreateMultiSelect_WithoutDDF)

            if "CARACTER_COLEGIO" in BT:
                self.CreateMultiSelect(label="CARACTER_COLEGIO",
                                       column="CARACTER_COLEGIO",
                                       options=self.df["CARACTER_COLEGIO"].drop_duplicates(
                                       ),
                                       fuction=self._CreateMultiSelect_WithoutDDF)

            if "PUNTAJE_ADMISION" in BT:
                min = self.df["PUNTAJE_ADMISION"].min()
                max = self.df["PUNTAJE_ADMISION"].max()
                self.CreateSlider(column="PUNTAJE_ADMISION",
                                  min_value=min,
                                  max_value=max,
                                  values=(min, max),
                                  format="%0.1f")

            if "COD_DEPTO_RESIDENCIA" in BT:
                self.CDRESIDENCIA = pd.read_csv(
                    "data/COD_DEPTO_RESIDENCIA.csv")
                self.CreateMultiSelect(label="COD_DEPTO_RESIDENCIA",
                                       column="COD_DEPTO_RESIDENCIA",
                                       options=self.CDRESIDENCIA.iloc[:, 1],
                                       fuction=self._CreateMultiSelect_WithDDF,
                                       df=self.CDRESIDENCIA)

            if "MUNICIPIO_RESIDENCIA" in BT:
                self.CreateMultiSelect(label="MUNICIPIO_RESIDENCIA",
                                       column="MUNICIPIO_RESIDENCIA",
                                       options=self.df["MUNICIPIO_RESIDENCIA"].dropna(
                                       ).drop_duplicates(),
                                       fuction=self._CreateMultiselectWithNAN)

            if "COD_PROVINCIA" in BT:
                self.CPROVINCIA = pd.read_csv("data/COD_PROVINCIA.csv")
                self.CreateMultiSelect(label="COD_PROVINCIA",
                                       column="COD_PROVINCIA",
                                       options=self.CPROVINCIA.iloc[:, 1],
                                       fuction=self._CreateMultiSelect_WithDDF,
                                       df=self.CPROVINCIA)
            if "MUNICIPIO_NACIMIENTO" in BT:
                self.CreateMultiSelect(label="MUNICIPIO_NACIMIENTO",
                                       column="MUNICIPIO_NACIMIENTO",
                                       options=self.df["MUNICIPIO_NACIMIENTO"].dropna(
                                       ).drop_duplicates(),
                                       fuction=self._CreateMultiselectWithNAN)

            if "COD_NACIONALIDAD" in BT:
                self.CNACIONALIDAD = pd.read_csv("data/COD_NACIONALIDAD.csv")
                self.CreateMultiSelect(label="COD_NACIONALIDAD",
                                       column="COD_NACIONALIDAD",
                                       options=self.CNACIONALIDAD.iloc[:, 1],
                                       fuction=self._CreateMultiSelect_WithDDF,
                                       df=self.CNACIONALIDAD)


        if BT:
            st.write(f"El **{round(len(self.modr)/len(self.df)*100, 2)}%** de los datos corresponden a los filtros seleccionados, es decir, se han encontrado **{len(self.modr)}**  elementos de **{len(self.df)}** datos.")
        viz = self.modr.copy()
        self.RenameColumns(self.modr,
                           columns=["COD_PLAN", "COD_DEPTO_RESIDENCIA", "COD_PROVINCIA", "COD_NACIONALIDAD"])

        st.dataframe(self.modr,
                     column_config={"AVANCE_CARRERA": st.column_config.ProgressColumn("AVANCE_CARRERA",
                                                                                      help="El avance del estudiante en su carrera actual",
                                                                                      min_value=0.0,
                                                                                      max_value=100.0,
                                                                                      format="%f"),
                                    "PUNTAJE_ADMISION": st.column_config.ProgressColumn("PUNTAJE_ADMISION",
                                                                                        help="Puntaje obtenido por el estudiante en la prueba de admision",
                                                                                        min_value=None,
                                                                                        max_value=888.484,
                                                                                        format="%f")},
                     use_container_width=True,
                     hide_index=True)
        if BT and len(self.modr) != 0:
            st.write("**Visualización de variables**")
            self.Select_Graficas(viz)

    def RenameColumns(self,
                      df: pd.DataFrame,
                      **args):
        # se encarga de renombrar las columnas del DataFrame según los datos proporcionados en archivos CSV específicos.
        # Recibe como argumento un diccionario donde las claves son los nombres de las columnas que se desean renombrar
        # y los valores son los nombres de los archivos CSV que contienen los datos de renombramiento. Itera sobre cada
        # par clave-valor y carga el archivo CSV correspondiente. Luego, mapea los valores de la columna del DataFrame
        # original a los valores de renombramiento utilizando la columna relevante del archivo CSV como índice. Esto
        # actualiza el DataFrame con las nuevas etiquetas de columna.
        for column in args["columns"]:
            rename = pd.read_csv(f"data/{column}.csv")
            vars = rename.columns[1]
            df[column] = df[column].map(
                rename.set_index(column)[vars])

    def CreateSlider(self,
                     column: str,
                     min_value: Union[int, float],
                     max_value: Union[int, float],
                     values: tuple,
                     format: str,
                     **args):
        # genera un widget interactivo de barra deslizante que permite al usuario seleccionar un rango de valores para una columna específica
        # del DataFrame. Con argumentos como el nombre de la columna, los valores mínimo y máximo, el formato de visualización y opciones
        # adicionales como el paso del slider, la función actualiza el DataFrame modr para incluir solo las filas que caen dentro del rango
        # seleccionado por el usuario en la columna especificada.
        if args:
            range = st.slider(column,
                              min_value=min_value,
                              max_value=max_value,
                              format=format,
                              value=values,
                              step=args["step"])
            if range[0] == min_value and range[1] == max_value:
                self.modr = self.modr
            else:
                self.modr = self.modr[(self.modr[column] <=
                                       range[1]) & (self.modr[column] >= range[0])]
        else:
            range = st.slider(column,
                              min_value=min_value,
                              max_value=max_value,
                              format=format,
                              value=values)
            self.modr = self.modr[(self.modr[column] <=
                                   range[1]) & (self.modr[column] >= range[0])]

    def _CreateMultiSelect_WithDDF(self,
                                   label: str,
                                   column: str,
                                   options: list,
                                   df: pd.DataFrame):
        # crea un widget de selección múltiple que muestra las opciones proporcionadas en forma de lista desplegable.
        # Cuando el usuario selecciona una o más opciones, la función actualiza el DataFrame modr para incluir solo las
        # filas donde los valores de la columna especificada (column) coinciden con las opciones seleccionadas por el usuario.
        # Utiliza un DataFrame auxiliar (df) para mapear las selecciones del usuario a los valores correspondientes de la
        # columna especificada.

        Select = st.multiselect(label=label,
                                options=options)
        Select = df[df.iloc[:, 1].isin(Select)].iloc[:, 0].tolist()
        self.modr = self.modr[self.modr[column].isin(Select)]

    def _CreateMultiSelect_WithoutDDF(self,
                                      label: str,
                                      column: str,
                                      options: list):
        # crea un widget de selección múltiple sin utilizar un DataFrame adicional. Muestra las opciones proporcionadas
        # en una lista desplegable y permite al usuario seleccionar una o más opciones. Luego, la función actualiza el
        # DataFrame modr para incluir solo las filas donde los valores de la columna especificada (column) coinciden con
        # las opciones seleccionadas por el usuario.
        Select = st.multiselect(label=label,
                                options=options)
        self.modr = self.modr[self.modr[column].isin(Select)]

    def _CreateMultiSelectModified(self,
                                   label: str,
                                   column: str,
                                   options: list,
                                   **args):
        # crea un widget de selección múltiple modificado para manejar una variable binaria específica. Permite al usuario seleccionar entre
        # las opciones proporcionadas, y si se selecciona "SI" pero no "NO", filtra el DataFrame modr para incluir solo las filas donde la
        # columna especificada (column) tenga el valor "SI". Del mismo modo, si se selecciona "NO" pero no "SI", filtra el DataFrame para
        # incluir solo las filas donde la columna tenga el valor "NO". Si ambas opciones están seleccionadas o ninguna está seleccionada,
        # no se realiza ningún filtrado y se mantiene el DataFrame original.
        Select = st.multiselect(label=label,
                                options=options)
        if "SI" in Select and "NO" not in Select:
            self.modr = self.modr[self.modr[column].isin(["SI"])]
        elif "NO" in Select and "SI" not in Select:
            self.modr = self.modr[self.modr[column].isin(["NO"])]
        else:
            self.modr = self.modr

    def _CreateMultiselectWithNAN(self,
                                  label: str,
                                  column: str,
                                  options: list):
        # crea un widget de selección múltiple que permite al usuario seleccionar opciones de una lista proporcionada.
        # Si no se selecciona ninguna opción, el DataFrame modr no se filtra y permanece sin cambios. Si se seleccionan
        # opciones, el DataFrame se filtra para incluir solo las filas donde la columna especificada (column) tenga valores
        # que coincidan con las opciones seleccionadas.

        Select = st.multiselect(label=label,
                                options=options)
        if not Select:
            self.modr = self.modr
        else:
            self.modr = self.modr[self.modr[column].isin(Select)]

    def CreateMultiSelect(self,
                          label: str,
                          column: str,
                          options: list,
                          fuction,
                          **args):
        # crea un widget de selección múltiple que permite al usuario seleccionar opciones de una lista proporcionada.
        if args:
            fuction(label, column, options, **args)
        else:
            fuction(label, column, options)
"""